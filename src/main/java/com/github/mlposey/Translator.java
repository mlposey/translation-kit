package com.github.mlposey;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * An asynchronous abstraction for web-based translation services.
 *
 * A Translator can perform the following operations asynchronously: <br>
 * - translate text from one language to another <br>
 * - identify the language of a text <br>
 * - determine if the service supports a translation direction (e.g., en-ru) <br><br>
 *
 * <p>You should have the appropriate API key set as an environment variable
 * before using any variation of this class. {@link Key} provides information
 * on naming conventions for Yandex and Google keys.</p>
 *
 * <p>Disregarding service restrictions, you can submit any number of requests
 * without waiting on previous results. Just ensure {@link Translator#shutdown(long)}
 * is called when the Translator will no longer accept requests. Queries cannot
 * be submitted after shutting the translator down.</p>
 */
public abstract class Translator {
    private String host;
    private final Key apiKey;

    private ExecutorService executor = Executors.newCachedThreadPool();

    /**
     * Constructs a Translator object.
     *
     * @param apiKey the API key for a translation service
     * @param host the host URL for the service (e.g., https://translation.googleapis.com/language/translate/v2)
     */
    public Translator(final Key apiKey, String host) {
        this.apiKey = apiKey;
        this.host = host;
    }

    /**
     * Stops all ongoing translations and shuts down the thread pool.
     *
     * <p>Once shut down, a Translator cannot be restarted. Further translations
     * require creation of a new Translator object.</p>
     *
     * @param timeout the time in seconds to wait before shutting down
     * @throws InterruptedException if all translations were not completed
     */
    public final void shutdown(long timeout) throws InterruptedException {
        executor.shutdown();
        executor.awaitTermination(timeout, TimeUnit.SECONDS);
    }

    /**
     * Translates text to another language.
     *
     * <p>This ignores possible errors generated by the translation service. To
     * handle them, use {@link Translator#translate(Text, Language, Consumer, Consumer)}
     * instead. If an error is generated, translate will not invoke consumer.</p>
     *
     * @param from the untranslated text
     * @param to the language into which 'from' should be translated
     * @param consumer consumes the resulting translation. Some services will
     *                 return many possible translations for a given text, so
     *                 the consumer should handle an array of Text objects.
     */
    public final void translate(final Text from, final Language to,
                                Consumer<Text[]> consumer) {
        assert(!executor.isShutdown());
        CompletableFuture.supplyAsync(() -> translateImpl(from, to), executor)
                         .thenAccept(consumer);
    }

    /**
     * Translates text to another language.
     *
     * @param from the untranslated text
     * @param to the language into which 'from' should be translated
     * @param consumer consumes the resulting translation. Some services will
     *                 return many possible translations for a given text, so
     *                 the consumer should handle an array of Text objects.
     * @param errorHandler called if translation fails. The error contains a
     *                     {@link TranslationError#getCode()} method that returns
     *                     the services error code. consumer is not invoked if
     *                     errorHandler is called.
     */
    public final void translate(final Text from, final Language to,
                                Consumer<Text[]> consumer,
                                Consumer<TranslationError> errorHandler) {
        assert(!executor.isShutdown());
        CompletableFuture.supplyAsync(() -> translateImpl(from, to), executor)
                         .exceptionally(ex -> {
                             errorHandler.accept((TranslationError)ex.getCause());
                             return null;
                         })
                         .thenAccept(consumer);
    }

    protected abstract Text[] translateImpl(final Text from, final Language to)
            throws TranslationError;

    /**
     * Identifies the language of a string of text.
     *
     * <p>This ignores possible errors generated by the translation service. To
     * handle them, use {@link Translator#identify(String, Consumer, Consumer)}
     * instead. If an error is generated, identify will not invoke consumer.</p>
     *
     * @param mysteryText a text of unknown language origins
     * @param consumer consumes the resulting language possibilities. Since some
     *                 text can span multiple languages (e.g., 'no'), the consumer
     *                 should process Language[].
     */
    public final void identify(String mysteryText, Consumer<Language[]> consumer) {
        assert(!executor.isShutdown());
        CompletableFuture.supplyAsync(() -> identifyImpl(mysteryText), executor)
                         .thenAccept(consumer);
    }

    /**
     * Identifies the language of a string of text.
     *
     * @param mysteryText a text of unknown language origins
     * @param consumer consumes the resulting language possibilities. Since some
     *                 text can span multiple languages (e.g., 'no'), the consumer
     *                 should process Language[].
     * @param errorHandler called if identification fails. The error contains a
     *                     {@link TranslationError#getCode()} method that returns
     *                     the services error code. consumer is not invoked if
     *                     errorHandler is called.
     */
    public final void identify(String mysteryText, Consumer<Language[]> consumer,
                               Consumer<TranslationError> errorHandler) {
        assert(!executor.isShutdown());
        CompletableFuture.supplyAsync(() -> identifyImpl(mysteryText), executor)
                         .exceptionally(ex -> {
                             errorHandler.accept((TranslationError)ex.getCause());
                             return null;
                         })
                        .thenAccept(consumer);
    }

    protected abstract Language[] identifyImpl(String mysteryText)
            throws TranslationError;

    /**
     * Determines the service's support for a translation direction.
     *
     * <p>This ignores possible errors generated by the translation service. To
     * handle them, use {@link Translator#hasSupport(Language, Language, Consumer, Consumer)}
     * instead. If an error is generated, hasSupport will not invoke consumer.</p>
     *
     * @param from the language of a potential source text
     * @param to the language of a potential target text
     * @param consumer consumes a boolean which is true if a translation
     *                 direction is supported or false if it is not.
     */
    public final void hasSupport(final Language from, final Language to,
                                 Consumer<Boolean> consumer) {
        assert(!executor.isShutdown());
        CompletableFuture.supplyAsync(() -> hasSupportImpl(from, to), executor)
                         .thenAccept(consumer);
    }

    /**
     * Determines the service's support for a translation direction.
     *
     * @param from the language of a potential source text
     * @param to the language of a potential target text
     * @param consumer consumes a boolean which is true if a translation
     *                 direction is supported or false if it is not.
     * @param errorHandler called if the query fails. The error contains a
     *                     {@link TranslationError#getCode()} method that returns
     *                     the services error code. consumer is not invoked if
     *                     errorHandler is called.
     */
    public final void hasSupport(final Language from, final Language to,
                                 Consumer<Boolean> consumer,
                                 Consumer<TranslationError> errorHandler) {
        assert(!executor.isShutdown());
        CompletableFuture.supplyAsync(() -> hasSupportImpl(from, to), executor)
                         .exceptionally(ex -> {
                             errorHandler.accept((TranslationError)ex.getCause());
                             return null;
                         })
                         .thenAccept(consumer);
    }

    protected abstract boolean hasSupportImpl(final Language from, final Language to)
            throws TranslationError;

    /**
     * Returns the host URL for the service (e.g., https://translation.googleapis.com/language/translate/v2).
     */
    protected String getHost() { return host; }

    /**
     * Returns the API key for the service
     * @see Key
     */
    protected Key getApiKey() {
        return apiKey;
    }
}
